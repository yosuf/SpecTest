module Assignments where

import Data.List
import System.Random
import Week6


-- Assignment 1
-- according to specification
exM' :: Integer -> Integer -> Integer -> Integer
exM' x y n = if y == ( calcBase2Exp y) then x^y `mod` n 
			else (( (x^(calcBase2Exp y) ) `mod` n ) * ( exM' x (y-(calcBase2Exp y)) n )) `mod` n

-- the value is logbase 2 which is either smaller or equal to the y
calcBase2Exp :: Integer -> Integer
calcBase2Exp y = getExpRem' 1 y  
			where 
			  getExpRem' x y = if (2^x) > y then 2^(x-1) else getExpRem' (x+1) y

testexM' :: Integer-> Integer -> Integer -> Bool
testexM' x y n = [exM' x' y' n'|x'<- [1..x], y'<-[2..y], n' <- [1..n] ] == [expM x' y' n'|x'<- [1..x], y'<-[2..y], n' <- [1..n] ]



{- Assignment 2
 Check that your implementation is more effcient than expM by running a number of relevant tests and documenting the results.

Answer: 
exM' is indeed more effecient.
Numbers lower than the ones noted below were very small to mention.

expM 	exM' 	args
-----------------------------------
1,99s	1,36s	23343 2433333 2534
19s		9s		23343 24333333 2534


 -}



{- Assignment 3
 In order to test Fermat’s Primality Check (as implemented in function primeF), 
 the list of prime numbers generated by Eratosthenes’ sieve is useless, 
 for Fermat’s Primality Check correctly classify the primes as primes. 
 Where the check can go wrong is on classifying composite numbers; these can slip through the Fermat test.
 Write a function composites :: [Integer] that generates the infinite list of composite natural numbers. 

 Hint: modify Eratosthenes’ sieve, so that instead of throwing away composite numbers, 
 it marks them as false. Next filter out the numbers marked as false.
-}

composites :: [Integer]
composites = filter (\m -> not $ isPrime m ) $ (filter (\ m -> (2^(m-1)) `mod` m == 1) [2..])



{-Assignment 4:
Use the list of composite numbers to test Fermat's primality check. What is the
least composite number that you can and that fools the check, for testF k with
k = 1; 2; 3 ? What happens if you increase k?

Answer: 
- Too much false positives and it differs each time

Usage: testF $ take 20 composites
-}
testF list = do
		primes <- sequence [ (primeF n x)  | n <- [3..15] , odd n , x <- list ]
	 	return [ (x,y) | x <-list , y<- primes ] 


{-Assignment 5
 Use the list generated by the following function for a further test of Fermat's Primality check. 

Answer: Use testF to pass carmicael list instead.
It strikes that the carmicael numbers seem to be much resistent to Fermat's check!

Usage: testF $ take 20 carmichael
-}
carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) | 
      k <- [2..], 
      isPrime (6*k+1), 
      isPrime (12*k+1), 
      isPrime (18*k+1) ]


{- Assignment 6:
Use the list from the previous exercise to test the Miller-Rabin primality check. What do you find?

Remark: Very few false positives!

Usage: testMR $ take 80 carmichael
-}
testMR list = do
		primes <- sequence [ (primeMR n x)  | n <- [3..15] , odd n ,  x <- list ]
	 	return primes




{- Assignment 7
You can use the Miller-Rabin primality check to discover some large Mersenne primes. 
The recipe: take a prime p, and use the Miller-Rabin algorithm to check whether 2p − 1 is also prime. 

Find information about Mersenne primes on inter- net and check whether the numbers that you found are genuine Mersenne primes. 
Report on your findings.

Usage: pGen primes

Link: http://www.isthe.com/chongo/tech/math/digit/m4423/prime.html
http://en.wikipedia.org/wiki/Mersenne_prime

Found until now: 22 + 1 + 1
Last found: 11213, 9941, 2^9689-1, 2^4423-1 
-}

pGen list = do
	finally <- sequence [mersenneCheck p | p <- list ]
	return finally


mersenneCheck p = 
	do 
	isPrimeAsMr <- (primeMR 29 ((2^p) - 1))	
	if isPrimeAsMr then putStrLn $ "Prime:  2^" ++  (show p)++ "-1"  else putStrLn $ "composite: " ++  (show p)++ "-1"

